[Awesome Medium Link To Learn Genetic Programming](https://medium.com/@aryamaanthakur/a-gentle-introduction-to-genetic-programming-d84a1514c66f)

Genetic Programming (GP) is a type of [EA](obsidian://open?vault=Thesis&file=Concpets%2FEvolutionary%20Algorithms) usually associated with the evolution of tree structures; it focuses on automatically creating computer programs by means of evolution ([[Koza]], 1992).

GP is generally interested in the space where there are many possible programs, but it is not clear which ones outperform the others and to what degree. In most GP approaches, the programs are represented using variable-sized tree genomes. The leaf nodes are called terminals, whereas the non-leaf nodes are called non-terminals or functions. The function set is the set of functions from which the GP system can choose when constructing trees; GP builds new trees by repeatedly selecting nodes from a function set and putting them together. The individuals in the initial population are typically randomly generated. The specification of the control parameters in a run is a mandatory preparatory step. There are several parameters, which some of the most important being: i) the population size; ii) the probabilities of performing the genetic operations; iii) the minimum and maximum tree sizes; and iv) the stopping criteria. It is impossible to define general guidelines for setting optimal parameter values, as these depend greatly on the details of the application. Nevertheless, GP is in practice robust, and it is likely that many different parameter values will work ([[Poli]], [[Langdon]], & [[Mcphee]], 2008). When applied to testing, GP trees are representations of the test programs that exercise the software under test.

The nodes of a [GP](obsidian://open?vault=Thesis&file=Concpets%2FGenetic%20Programming) tree are usually not typed – i.e., all the functions are able to accept every conceivable argument. Type consistency ([[Koza]], 1994) ensures that operators will always produce legal offspring – i.e., crossover is not able to attempt incompatible connections between nodes, and mutation does not produce illegal programs. An implicit assumption underlying type consistency is that all combinations of structures are equally likely to be useful; in many cases, however, it is known in advance that there are constraints on the structure of the potential solutions. What’s more, the nonexistence of types may lead to the generation of syntactically incorrect parse trees; specifically, non-typed GP approaches are unsuitable for representing OO programs ([[Haynes]], [[Schoenefeld]], & [[Wainwright]], 1996)

Strongly-Typed Genetic Programming (STGP) ([[Montana]], 1993) is arguably the most natural approach to incorporate types and their constraints into GP ([[Poli]] et al., 2008), since constraints are often expressed using a type system. Variables, constants, arguments and returned values can be of any data type, with the provision that the data type for each such value is specified beforehand in the function set. The STGP search space is the set of all legal parse trees and is thus particularly suited for representing OO programs, as it enables the reduction of the search space to the set of compilable, i.e., formally feasible ([[Wappler]], 2007), programs by allowing the definition of constraints that eliminate invalid combinations of operations. In addition, STGP has already been extended to support more complex type systems, including simple generics ([[Montana]], 1995), inheritance ([[Haynes]] et al., 1996), and polymorphism ([[Olsson]], 1994; Yu, 2001).